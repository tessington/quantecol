type = "l",
lwd = 3,
xlab = "r",
ylab = "Negative log-likelihood profile",
ylim = c(12.5, 18.7),
xlim = c(0, 0.3))
plot(rlist, r.profile,
type = "l",
lwd = 3,
xlab = "r",
ylab = "Negative log-likelihood profile",
ylim = c(12.5, 18.7),
xlim = c(0, 0.3),
las =1)
target.nll <- min.nll + 1.92
ci.index <- which(r.profile <= target.nll)
lb <- rlist[min(ci.index)]
ub <- rlist[max(ci.index)]
r.profile <- apply(X = nll.matrix, MAR = 1, FUN = min)
# get confidence interval
min.nll <- min(r.profile)
r.mle <- rlist[rprofile==min.nll]
r.mle <- rlist[r.profile==min.nll]
target.nll <- min.nll + 1.92
ci.index <- which(r.profile <= target.nll)
lb <- rlist[min(ci.index)]
ub <- rlist[max(ci.index)]
abline(h = min.nll, lwd = 3, lty = "dashed")
r.mle <- rlist[r.profile==min.nll]
target.nll <- min.nll + 1.92
ci.index <- which(r.profile <= target.nll)
lb <- rlist[min(ci.index)]
ub <- rlist[max(ci.index)]
lines(c(lb, ub), rep(target.nll, 2), lwd =3, col = "gray")
lines(c(lb, ub), rep(target.nll, 2), lwd =4, col = "gray")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig8.5_6.R', echo=TRUE)
fig8.5_6()
help(warning)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig8.5_6.R', echo=TRUE)
fig8.5_6()
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig8.5_6.R', echo=TRUE)
fig8.5_6()
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig8.5_6.R', echo=TRUE)
fig8.5_6()
options (warn = -1
# find maximum likelihood using numerical optimization
start.pars <- c(0.1, 10)
nb.soln <- optim(par = start.pars,
fn = nll.fun,
thedata = thedata,
t = t,
method = "Nelder-Mead")
return(list(r.mle.grid = r.mle, r.mle.numeric = nb.soln$par[1], k.mle.grid = k.mle,
k.mle.numeric = nb.soln$par[2], r.ci = c(lb, ub)))
}
options (warn = -1)
options (warn = -1)
# find maximum likelihood using numerical optimization
start.pars <- c(0.1, 10)
nb.soln <- optim(par = start.pars,
fn = nll.fun,
thedata = thedata,
t = t,
method = "Nelder-Mead",
options = options)
help(optim)
nb.soln <- optim(par = start.pars,
fn = nll.fun,
thedata = thedata,
t = t,
method = "Nelder-Mead")
options (warn = -1)
# find maximum likelihood using numerical optimization
start.pars <- c(0.1, 10)
nb.soln <- optim(par = start.pars,
fn = nll.fun,
thedata = thedata,
t = t,
method = "Nelder-Mead")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig8.5_6.R', echo=TRUE)
fig8.5_6()
soln <- fig8.5_6()
print(soln)
rm(list = ls())
library(quantecol)
print(fig8.5_6_
)
print(fig8.5_6)
library(quantecol)
fig8.5_6()
print(fig8.5_6)
n.init <- gobies$initial_number
n.final <- gobies$final_number
nll.fun <- function(par, n.init, n.final) {
p.max <- par[1]
alpha <- par[2]
ps <- p.max * exp(-alpha * n.init)
return(-sum(dbinom(x = n.final,
size = n.init,
prob = ps,
log = T)))
}
start.par <- c(0.7, 0.01)
fit <- optim(par = star.par,
fn = nll.fun,
n.init = n.init,
n.final = n.final,
method = "Nelder-Mead")
fit <- optim(par = start.par,
fn = nll.fun,
n.init = n.init,
n.final = n.final,
method = "Nelder-Mead")
fit
# Plot the data
plot(n.init, n.final,
type = "p",
pch = 21,
bg = "black",
xlab = expression(paste("N"[0])),
ylab = expression(paste("N"["survive"])),
xlim = c(0, 90),
ylim = c(0, 20),
xaxs = "i",
yaxs = "i",
las = 1)
# plot best fit
n.init.list <- 0:80
pmax.mle <- fit$par[1]
alpha.mle <- fit$par[2]
n.hat <- pmax.mle * n.init.lit * exp(-alpha.mle * n.init.list)
n.hat <- pmax.mle * n.init.list * exp(-alpha.mle * n.init.list)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
fig8.8()
library(quantecol)
help(fig8.8)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig8.8.R', echo=TRUE)
library(quantecol)
help(fig8.8)(
help(fig8.8)
library(quantecol)
help(dbinom)
source('~/.active-rstudio-document', echo=TRUE)
k <- c(79, 70)
E <- c(0.267, 0.213)
N <- c(1024, 990)
qlist <- seq(from = 0.2, to = 0.45, by = 0.001)
nll.list <- rep(x = NA, times = length(qlist))
for (i in 1:length(qlist)) {
p <- E * qlist[i]
nll.list[i] <- -sum(dbinom(k, size = N, prob = p, log = T))
}
min.mle <- min(nll.list)
q.mle <- qlist[nll.list== min.mle]
target.nll <- min.mle + 1.92
ci.range <- which(nll.list <= target.nll)
lb <- qlist[min(ci.range)]
lb <- qlist[max(ci.range)]
# Make plot
plot(qlist, nll.list,
type = "l",
lwd = 3,
ylim = c(6, 20),
xlim = c(0.2, 0.45),
xlab = "Catchability (q)",
ylab = "Negative log-likelihood"
)
lines(c(lb, ub), rep(target.nll, 2), lwd = 3, col = "gray")
lb <- qlist[min(ci.range)]
ub <- qlist[max(ci.range)]
# Make plot
plot(qlist, nll.list,
type = "l",
lwd = 3,
ylim = c(6, 20),
xlim = c(0.2, 0.45),
xlab = "Catchability (q)",
ylab = "Negative log-likelihood"
)
lines(c(lb, ub), rep(target.nll, 2), lwd = 3, col = "gray")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
fig8.7()
source('~/.active-rstudio-document', echo=TRUE)
library(quantecol)
help(fig8.7)
library(quantecol)
help(fig8.7)
library(quantecol)
killerwhales
year.list <- killerwhales$Year
alive <- killerwhales$Count
nyear <- length(year.list)
plot(alive[-nyear], alive[-1],
type ="p",
pch = 21,
bg = "black",
xlab = expression("N"["t"]),
ylab = expression("N"["t+1"]),
xlim =c(0,105),
ylim = c(0,105),
las =1,
yaxs = "i",
xaxs = "i")
year.list <- killerwhales$Year
alive <- killerwhales$Count
nyear <- length(year.list)
plot(alive[-nyear], alive[-1],
type ="p",
pch = 21,
bg = "black",
xlab = expression("N"["t"]),
ylab = expression("N"["t+1"]),
xlim =c(0,105),
ylim = c(0,105),
las =1,
yaxs = "i",
xaxs = "i")
fitdi <- function(pars, data){
lambda <- pars[1]
ndata <- nrow(data)
ntplus.one.hat <- data[-ndata,1] * lambda
nll <- -sum(dpois(data[,2], ntplus.one.hat, log = T))
return(nll)
}
optim.data <- cbind(alive[-nyear], alive[-1])
startpars <- 1.002
solve.di <- optim(par = startpars, fn = fitdi, data = optim.data, method = "Brent", lower = 0.5, upper = 1.1 )
solve.di
fit.logistic <- function(pars, data){
r <- exp(pars[1])
k <- exp(pars[2])
ndata <- length(data)
n.tplus1.hat <- data[-ndata,1] * r * (1 - data[-ndata,1] / k)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(NLL)
}
fit.logistic <- function(pars, data){
r <- exp(pars[1])
k <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* r * (1 - n.t / k)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(NLL)
}
startpars <- c(log(0.002), 4)
solve.logistic <- optim(par = startpars, fn = fitdd, data = optim.data, method = "BFGS")
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
fit.logistic <- function(pars, data){
r <- exp(pars[1])
k <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* r * (1 - n.t / k)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
fitbh <- function(pars, data) {
alpha <- exp(pars[1])
beta <- exp(pars[2])
NLL <- 0
for (i in 1:nrow(data)){
NLL <- NLL - dpois(data[i,2],data[i,1]+alpha*data[i,1]/(1+data[i,1]*beta),log = T)
}
return(NLL)
}
startpars <- c(log(0.002), 4)
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
print(exp(solve.dd$par))
print(exp(solve.logistic$par))
print(solve.logistic$value)
fit.bh <- function(pars, data) {
alpha <- exp(pars[1])
beta <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* alpha / ( 1 + n.t * beta)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
# fit a BH model
startpars <- c(log(0.002), log(.02))
solve.bh <- optim(par = startpars, fn = fit.bh, data = optim.data, method = "BFGS")
print(exp(solve.bh$par))
print(solve.bh$value)
rownames(AICtable) <- c("Density independent", "Logistic", "Beverton-Holt")
AICtable <- matrix(NA, nrow = 3, ncol = 3)
rownames(AICtable) <- c("Density independent", "Logistic", "Beverton-Holt")
# fit a BH model
startpars <- c(log(0.002), log(.02))
solve.bh <- optim(par = startpars, fn = fit.bh, data = optim.data, method = "BFGS")
print(exp(solve.bh$par))
print(solve.bh$value)
AICtable <- matrix(NA, nrow = 3, ncol = 3)
rownames(AICtable) <- c("Density independent", "Logistic", "Beverton-Holt")
colnames(AICtable) <- c("NLL", "AIC", "Delta AIC")
AICtable[,1] <- c(solve.di$value2, solve.logistic$value, solve.bh$value)
AICtable[,1] <- c(solve.di$value, solve.logistic$value, solve.bh$value)
AICtable[,2] <- 2 * AICtable[,1] + 2 * c(1,2,2)
AICtable[,3] <- AICtable[,2] - min(AICtable[,2])
AICtable
source('~/Dropbox/Desktop/Rcode/FSH454/model selection/killerwhalemodelselection.R', echo=TRUE)
thedata
cbind(yearlist, alive)
cbind(year.list, alive)
killerwhales
AICtable
year.list <- killerwhales$Year
alive <- killerwhales$Count
nyear <- length(year.list)
plot(alive[-nyear], alive[-1],
type ="p",
pch = 21,
bg = "black",
xlab = expression("N"["t"]),
ylab = expression("N"["t+1"]),
xlim =c(0,105),
ylim = c(0,105),
las =1,
yaxs = "i",
xaxs = "i")
fitdi <- function(pars, data){
lambda <- pars[1]
ndata <- nrow(data)
ntplus.one.hat <- data[-ndata,1] * lambda
nll <- -sum(dpois(data[,2], ntplus.one.hat, log = T))
return(nll)
}
optim.data <- cbind(alive[-nyear], alive[-1])
startpars <- 1.002
solve.di <- optim(par = startpars, fn = fitdi, data = optim.data, method = "Brent", lower = 0.5, upper = 1.1 )
fit.logistic <- function(pars, data){
r <- exp(pars[1])
k <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* r * (1 - n.t / k)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
fit.bh <- function(pars, data) {
alpha <- exp(pars[1])
beta <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* alpha / ( 1 + n.t * beta)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
startpars <- c(log(0.002), 4)
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
print(exp(solve.logistic$par))
print(solve.logistic$value)
solve.di
startpars <- c(log(0.002), 4)
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
print(exp(solve.logistic$par))
print(solve.logistic$value)
startpars <- c(log(0.002), log(100000))
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
solve.logistic$value
solve.di$par
startpars <- c(log(0.0011), log(100000))
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
solve.logistic$value
startpars <- c(log(0.0011), log(1000))
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
solve.logistic$value
log(1000)
log(100)
startpars <- c(log(0.0011), log(100))
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
solve.logistic
startpars <- c(log(0.002), 4)
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
solve.logist
solve.logistic
# fit a BH model
startpars <- c(log(0.002), log(.02))
solve.bh <- optim(par = startpars, fn = fit.bh, data = optim.data, method = "BFGS")
print(exp(solve.bh$par))
print(solve.bh$value)
# fit a BH model
startpars <- c(log(0.002), log(.01))
solve.bh <- optim(par = startpars, fn = fit.bh, data = optim.data, method = "BFGS")
print(exp(solve.bh$par))
print(solve.bh$value)
AICtable <- matrix(NA, nrow = 3, ncol = 3)
rownames(AICtable) <- c("Density independent", "Logistic", "Beverton-Holt")
colnames(AICtable) <- c("NLL", "AIC", "Delta AIC")
AICtable[,1] <- c(solve.di$value, solve.logistic$value, solve.bh$value)
AICtable[,2] <- 2 * AICtable[,1] + 2 * c(1,2,2)
AICtable[,3] <- AICtable[,2] - min(AICtable[,2])
AICtable
exp(solve.logistic$par)
startpars <- c(log(0.002), 8)
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
exp(solve.logistic$par)
fitdi <- function(pars, data){
lambda <- pars[1]
ndata <- nrow(data)
n.t <- data[-ndata,1]
ntplus.one.hat <- n.t * lambda
nll <- -sum(dpois(data[,2], ntplus.one.hat, log = T))
return(nll)
}
optim.data <- cbind(alive[-nyear], alive[-1])
startpars <- 1.002
solve.di <- optim(par = startpars, fn = fitdi, data = optim.data, method = "Brent", lower = 0.5, upper = 1.1 )
fit.logistic <- function(pars, data){
r <- exp(pars[1])
k <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* r * (1 - n.t / k)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
fit.bh <- function(pars, data) {
alpha <- exp(pars[1])
beta <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* alpha / ( 1 + n.t * beta)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
exp(solve.bh$par)
abline(a = 0, b = solve.di$par)
View(cbind(year.list, alive)
thedata <- read.csv(file = "~/Dropbox/Desktop/Rcode/FSH454/model selection/raw_data.csv", header = T)
year.list <- 1974:2017
alive <- rep(NA, length(year.list))
cbine(year.list, alive)
cbind(year.list, alive)
# replace NA with a BIG number
x <- thedata$birth
y <- thedata$death
y <- replace(y, which(is.na(y)), 3000)
for (i in 1:length(year.list)) {
born<- which(x<=year.list[i])
# of those born prior, how many still alive
alive[i] <- length(which(y[born]>=year.list[i]))
}
nyear <- length(year.list)
cbind(year.list, alive)
killerwhale_model_select <- function() {
year.list <- killerwhales$Year
alive <- killerwhales$Count
nyear <- length(year.list)
plot(alive[-nyear], alive[-1],
type ="p",
pch = 21,
bg = "black",
xlab = expression("N"["t"]),
ylab = expression("N"["t+1"]),
xlim =c(0,105),
ylim = c(0,105),
las =1,
yaxs = "i",
xaxs = "i")
fitdi <- function(pars, data){
lambda <- pars[1]
ndata <- nrow(data)
n.t <- data[-ndata,1]
ntplus.one.hat <- n.t * lambda
nll <- -sum(dpois(data[,2], ntplus.one.hat, log = T))
return(nll)
}
optim.data <- cbind(alive[-nyear], alive[-1])
startpars <- 1.002
solve.di <- optim(par = startpars, fn = fitdi, data = optim.data, method = "Brent", lower = 0.5, upper = 1.1 )
fit.logistic <- function(pars, data){
r <- exp(pars[1])
k <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* r * (1 - n.t / k)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
fit.bh <- function(pars, data) {
alpha <- exp(pars[1])
beta <- exp(pars[2])
ndata <- length(data)
n.t <- data[-ndata,1]
n.tplus1.hat <- n.t + n.t* alpha / ( 1 + n.t * beta)
nll <- - sum(dpois(data[,2], n.tplus1.hat, log = T))
return(nll)
}
startpars <- c(log(0.002), 4)
solve.logistic <- optim(par = startpars, fn = fit.logistic, data = optim.data, method = "BFGS")
# fit a BH model
startpars <- c(log(0.002), log(.01))
solve.bh <- optim(par = startpars, fn = fit.bh, data = optim.data, method = "BFGS")
AICtable <- matrix(NA, nrow = 3, ncol = 3)
rownames(AICtable) <- c("Density independent", "Logistic", "Beverton-Holt")
colnames(AICtable) <- c("NLL", "AIC", "Delta AIC")
AICtable[,1] <- c(solve.di$value, solve.logistic$value, solve.bh$value)
AICtable[,2] <- 2 * AICtable[,1] + 2 * c(1,2,2)
AICtable[,3] <- AICtable[,2] - min(AICtable[,2])
}
source('~/Dropbox/Desktop/Rcode/quantecol/R/killerwhale_modelselection.R', echo=TRUE)
killerwhale_model_select()
source('~/Dropbox/Desktop/Rcode/quantecol/R/killerwhale_modelselection.R', echo=TRUE)
killerwhale_model_select()
source('~/Dropbox/Desktop/Rcode/quantecol/R/whale_model_select.R', echo=TRUE)
library(quantecol)
help(whale_model_select)
print(whale_model_select)
