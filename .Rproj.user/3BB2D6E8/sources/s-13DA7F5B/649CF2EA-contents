rm(list = ls())

# thedata <- read.csv(file = "raw_data.csv", header = T)
# year.list <- 1974:2017
# alive <- rep(NA, length(year.list))
#
#
#   # replace NA with a BIG number. NA means that the whale is not yet dead
#   x <- thedata$birth
#   y <- thedata$death
#   y <- replace(y, which(is.na(y)), 3000)
#
#   # which were born prior of in this year
#
#   for (i in 1:length(year.list)) {
#   born<- which(x<=year.list[i])
#   # of those born prior, how many still alive
#   alive[i] <- length(which(y[born]>=year.list[i]))
#   }
#
#
# repeat, instead use Center for Whale Research
cwwdata <- read.csv(file = "R/stochastic population models/cww_killerwhale.csv", header = T)
 # make comparable to before, up to 2017:
#cwwdata <- cwwdata[1:43,]
year.list <- cwwdata[,1]
alive <- cwwdata[,2]
plotfilename <- "R/stochastic population models/killerwhales.pdf"
pdf(file = plotfilename,
    width = 5,
    height = 4)

plot(year.list, alive,
     type = "l",
     lwd = 2,
     xlab = "Year",
     ylab = "Population Size",
     las = 1)

points(year.list, alive,
       pch = 21,
       bg = "black")

dev.off()
system2("open",args = c("-a Skim.app",plotfilename))
# get r_t

rt <- log(alive[-1]/alive[-length(alive)])


mu <- mean(rt)
sigma <- sd(rt)
se <- sigma / (length(rt))^(.5)

alpha <- 0.05
df <- length(rt)-1

t.2.use <- qt(alpha/2, lower.tail = F, df=df)


ci <- c(mu - t.2.use * se, mu + t.2.use*se); print(ci)
# get extinction risk from Dennis:

(alive[length(alive)]/ 30)^(-2*mu / (sigma^2))

1# get confidence interval for sigma

sigma2.ci.upper <-df*sigma^2/qchisq(0.025, df)
sigma2.ci.lower <- df*sigma^2 / qchisq(0.975, df)
sigma2.ci <- c(sigma2.ci.lower, sigma2.ci.upper)
pnorm(log(40/alive[length(alive)]), mean= mu, sd = sigma, lower.tail = T)


## AUTOCORRELATION   plot
 plotfilename <- "R/stochastic population models/autocorrwhales.pdf"
 pdf(file = plotfilename,
     width = 5,
     height = 4)

 plot(year.list[-length(year.list)], rt,
      type = "l",
      lwd = 2,
      xlab = "Year",
      ylab = expression(paste("r"["t"])),
      las = 1)

 points(year.list[-length(year.list)], rt,
        pch = 21,
        bg = "black")
 dev.off()
 system2("open",args = c("-a Skim.app",plotfilename))

# calculate nll
nll.fun <- function(pars, x) {
  n <- length(x)
  nminus1 <- n -1
  rbar <- pars[1]
  sigma <- pars[2]
  rho <- pars[3]
  # get NLL for first observation
  sigma.year.1 <- sqrt(sigma^2 / (1-rho^2))
  nll <- rep(NA, n)
  nll[1]<-dnorm(x[1], mean = rbar, sd = sigma.year.1, log = T)

  eta<- x-rbar
  for (i in 2:n) {
    v.tmp <- eta[i]-rho*eta[i-1]
    nll[i]<-dnorm(v.tmp, mean = 0, sd = sigma, log = T)
  }
  return(-sum(nll))
}

pars <- c(rbar = mu, sigma = sigma, rho = 0.5)
soln <- optim(par = pars, fn = nll.fun,x = rt, method = "L-BFGS-B", lower = c(-Inf, 0.001, 0), upper = c(Inf, Inf, .9))

# simulate model for a brief policy relevant time, 50 years

tmax.use <-  100
rho.use <- soln$par[3]
rhat.use <- soln$par[1]
no.use <- alive[length(alive)]
nextinct.use <- 40
sigma.use <- soln$par[2]


run.stochastic <- function(pars) {
  with(pars, {
    extinct.flag <- 0
    vt <- rnorm(tmax, mean = 0, sd = sigma)
    nt <- no
    eta<- rt <- nt <- rep(NA, tmax)

    eta[1] <- vt[1]
    nt[1] <- no

    for (t in 2:tmax) eta[t] <- rho * eta[t-1] + vt[t] * sqrt(1- rho^2)
    rt <- rbar + eta
    for (t in 1:(tmax - 1))  {
      nt[t+1] <- nt[t] * exp(rt[t])
      if (nt[t+1] <= nextinct) break
    }
    if (nt[t+1] <= nextinct) extinct.flag <- 1

  return(extinct.flag)
  })
}

pars <- list(tmax = tmax.use, rho = 0, rbar = mu, sigma = sigma, no = no.use, nextinct = nextinct.use)

n.iters <- 10000
output <- rep(NA, n.iters)
for (i in 1:n.iters) {
  output[i] <- run.stochastic(pars)
}
sum(output) / n.iters

# repeat with autocorrelation
pars$rho <- soln$par[3]
output <- rep(NA, n.iters)
for (i in 1:n.iters) {
  output[i] <- run.stochastic(pars)
}
sum(output)/n.iters
# calculate extinction without rho but using monte carlo for rbar and sigma


n.iters <- 10000
output <- rep(NA, n.iters)
rhat.2.use <- rnorm(n.iters, mu, se)
sigma.2.use <- sqrt(sigma^2*rchisq(n.iters, df = df)/df)


par$rho <- 0
for (i in 1:n.iters) {

  pars$rbar <- rhat.2.use[i]
  pars$sigma <- sigma.2.use[i]
  output[i]<-run.stochastic(pars)
}
sum(output) / n.iters
