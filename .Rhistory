dxdt.t.minus1 <- dXYdt.t[t-2,1]
dydt.t.minus1 <- dXYdt.t[t-2,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  deltat /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  deltat /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t-1,] <- c(dxdt.t, dydt.t)
}
return(output)
rx=0.5
Kx=87.25
alpha=0.75
ry=0.5
Ky=87.25
beta=.75
t.perturb=20
n.years<-100
# Get Equilibrium
Xstar <- (Kx - alpha * Ky) / (1 - alpha * beta)
Ystar <- (Ky - beta*Kx) / (1 - alpha * beta)
# function to run the Adams - Bashford method to simulate the differential equations
run.dxydt<-function(Xstart,
Ystart,
parslist,
t.perturb = 20,
perturb = c(1.05,1),
n.years = 100,
deltat = 0.1) {
rx <- parslist$rx
Kx<-parslist$Kx
alpha<-parslist$alpha
ry <- parslist$ry
Ky <- parslist$Ky
beta<-parslist$beta
timelist <- seq(0, n.years, by = deltat)
n.steps<-length(timelist)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-2,1]
dydt.t.minus1 <- dXYdt.t[t-2,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  deltat /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  deltat /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t-1,] <- c(dxdt.t, dydt.t)
}
return(output)
}
output<-run.dxydt(Xstart,Ystart,parslist, t.perturb=t.peturb,perturb=c(1.05,1),n.years = n.years,
deltat = deltat)
output<-run.dxydt(Xstart,Ystart,parslist, t.perturb=t.perturb,perturb=c(1.05,1),n.years = n.years,
deltat = deltat)
output
plot((1:nrow(output))*deltat,output[,1],type="l",col="black",lwd=3,xlab="",ylab="",ylim=c(0,110),xaxs="i", axes = "F")
box()
mtext(side = 1, line = 1, text = "Time")
mtext(side = 2, line = 1, text = "State Variable", las = 0)
lines(1:nrow(output)*deltat,
output[,2],
type = "l",
lwd = 3,
col = "gray50")
output
perturb
View(output)
timelist
t=201
dxdt.t.minus1 <- dXYdt.t[t-2,1]
dydt.t.minus1 <- dXYdt.t[t-2,2]
dxdt.t.minus1
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
X.t
Y.t
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
X.t
Y.t
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
dxdt.t
dydt.t
Xt.plus1 <- X.t +  deltat /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  deltat /2 * (3*dydt.t - dydt.t.minus1[1])
Yt.plus1
Xt.plus1
t
t <- 202
dxdt.t.minus1 <- dXYdt.t[t-2,1]
dydt.t.minus1 <- dXYdt.t[t-2,2]
dydt.t.minus1
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
dydt.t
X.t
Y.t
# function to run the Adams - Bashford method to simulate the differential equations
run.dxydt<-function(Xstart,
Ystart,
parslist,
t.perturb = 20,
perturb = c(1.05,1),
n.years = 100,
deltat = 0.1) {
rx <- parslist$rx
Kx<-parslist$Kx
alpha<-parslist$alpha
ry <- parslist$ry
Ky <- parslist$Ky
beta<-parslist$beta
timelist <- seq(0, n.years, by = deltat)
n.steps<-length(timelist)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-2,1]
dydt.t.minus1 <- dXYdt.t[t-2,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,2]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  deltat /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  deltat /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t-1,] <- c(dxdt.t, dydt.t)
}
return(output)
}
rx=0.5
Kx=87.25
alpha=0.75
ry=0.5
Ky=87.25
beta=.75
t.perturb=20
n.years<-100
# Get Equilibrium
Xstar <- (Kx - alpha * Ky) / (1 - alpha * beta)
Ystar <- (Ky - beta*Kx) / (1 - alpha * beta)
Xstart=Xstar
Ystart=Ystar
parslist <- list(rx = rx, Kx = Kx, alpha = alpha, ry = ry, Ky = Ky, beta = beta)
output<-run.dxydt(Xstart,Ystart,parslist, t.perturb=t.perturb,perturb=c(1.05,1),n.years = n.years,
deltat = deltat)
plot((1:nrow(output))*deltat,output[,1],type="l",col="black",lwd=3,xlab="",ylab="",ylim=c(0,110),xaxs="i", axes = "F")
box()
mtext(side = 1, line = 1, text = "Time")
mtext(side = 2, line = 1, text = "State Variable", las = 0)
lines(1:nrow(output)*deltat,
output[,2],
type = "l",
lwd = 3,
col = "gray50")
# repeat with new alpha and beta, keeping equilibrium the same
alpha=1.25
beta=1.25
plot.new()
par <- settings::reset_par()
help(reset_par)
par()
par$mfrow
plot((1:nrow(output))*deltat,output[,1],type="l",col="black",lwd=3,xlab="",ylab="",ylim=c(0,110),xaxs="i", axes = "F")
box()
mtext(side = 1, line = 1, text = "Time")
mtext(side = 2, line = 1, text = "State Variable", las = 0)
lines(1:nrow(output)*deltat,
output[,2],
type = "l",
lwd = 3,
col = "gray50")
# repeat with new alpha and beta, keeping equilibrium the same
alpha=1.25
beta=1.25
rm=0.5
Km=100
alpha=0.95
rb=0.5
Kb=100
beta=.95
mult=c(0.95,1)
deltat=0.1
t.perturb=20
t.run<-100
Mstar <- 51
Bstar <- 49
alpha=0.75
beta=0.75
Km <- Mstar + Bstar*alpha
Kb <- Bstar + Mstar*beta
Km
Kb
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1()
fig4.1("stable")
fig4.1("stable")
fig4.1("unstable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
help(plot.new)
help(frame)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
alpha=1.25
beta=1.25
Km <- Mstar + Bstar*alpha
Kb <- Bstar + Mstar*beta
Km
Kb
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
fig4.1("stable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("stable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("stable")
fig4.1("unstable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
fig4.1("stable")
par()
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("stable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/reset_graphics_par.R', echo=TRUE)
fig4.1("stable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/reset_graphics_par.R', echo=TRUE)
reset_graphics_par()
source('~/Dropbox/Desktop/Rcode/ecomodeling_book/R/multi_variable_stability_analysis/plot stability example.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("stable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/reset_graphics_par.R', echo=TRUE)
fig4.1("stable")
fig4.1("unstable")
library(quantecol)
fig4.1()
fig4.1("unstable")
help(fig4.1)
A <- matrix(c(axx, axy, ayy, ayx), byrow = T, nrow = 2, ncol= 2)
# calculate Jacobian Matrix
axx <- rx - 2 * rx * Xstar / Kx - rx * alpha * Ystar/Kx
stability= "stable"
# function to run the Adams - Bashford method to simulate the differential equations
run.dxydt<-function(Xstart,
Ystart,
parslist,
t.perturb = 20,
perturb = c(1.05,1),
n.years = 100,
deltat = 0.1) {
rx <- parslist$rx
Kx<-parslist$Kx
alpha<-parslist$alpha
ry <- parslist$ry
Ky <- parslist$Ky
beta<-parslist$beta
timelist <- seq(0, n.years, by = deltat)
n.steps<-length(timelist)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-2,1]
dydt.t.minus1 <- dXYdt.t[t-2,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,2]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  deltat /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  deltat /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t-1,] <- c(dxdt.t, dydt.t)
}
return(output)
}
# set up parameters
rx<-0.5
ry<-0.5
if(stability == "stable") {
alpha <- 0.75
beta <- 0.75
Kx <- 87.75
Ky <- 87.25
}
if(stability == "unstable") {
alpha <- 1.25
beta <- 1.25
Kx <- 112.25
Ky <- 112.75
}
parslist <- list(rx = rx, Kx = Kx, ry = ry, Ky = Ky, alpha = alpha, beta = beta)
# year of the perturbation
t.perturb=20
# how many years to simulate
n.years<-100
# Get Equilibrium
Xstar <- (Kx - alpha * Ky) / (1 - alpha * beta)
Ystar <- (Ky - beta*Kx) / (1 - alpha * beta)
# Set starting values at equilibrium
Xstart=Xstar
Ystart=Ystar
# call the run.dxydt function to get the model dynamics
output<-run.dxydt(Xstart,Ystart,parslist, t.perturb=t.perturb,perturb=c(1.05,1),n.years = n.years,
deltat = deltat)
# plot the output
reset_graphics_par()
plot((1:nrow(output)) * deltat,
output[, 1],
type = "l",
col = "black",
lwd = 3,
xlab = "",
ylab = "",
ylim = c(0, 110),
xaxs = "i",
axes = "F"
)
box()
mtext(side = 1, line = 1, text = "Time")
mtext(side = 2, line = 1, text = "State Variable", las = 0)
lines(1:nrow(output)*deltat,
output[,2],
type = "l",
lwd = 3,
col = "gray50")
# calculate Jacobian Matrix
axx <- rx - 2 * rx * Xstar / Kx - rx * alpha * Ystar/Kx
axy <- -rx * alpha * Xtar / Kx
ayy <- ry/ Ky * (Ky - 2 * Ystar - beta * Xstar)
ayx <- -ry * beta * Ystar / Ky
axy <- -rx * alpha * Xstar / Kx
ayy <- ry/ Ky * (Ky - 2 * Ystar - beta * Xstar)
ayx <- -ry * beta * Ystar / Ky
A <- matrix(c(axx, axy, ayy, ayx), byrow = T, nrow = 2, ncol= 2)
A
ayx
ev <- eigen(A)
ev
fig4.1()
fig4.1("unstable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
# calculate Jacobian Matrix
axx <- rx - 2 * rx * Xstar / Kx - rx * alpha * Ystar/Kx
axy <- -rx * alpha * Xstar / Kx
ayy <- ry - 2 * ry * Ystar / Ky - ry * beta * Xstar/Ky
ayx <- -ry * beta * Ystar / Ky
axx
axy
ayx
A <- matrix(c(axx, axy, ayy, ayx), byrow = T, nrow = 2, ncol= 2)
ev <- eigen(A)$values
ev
alpha <- 1.25
beta <- 1.25
Kx <- 112.25
Ky <- 112.75
# calculate Jacobian Matrix
axx <- rx - 2 * rx * Xstar / Kx - rx * alpha * Ystar/Kx
axy <- -rx * alpha * Xstar / Kx
ayy <- ry - 2 * ry * Ystar / Ky - ry * beta * Xstar/Ky
ayx <- -ry * beta * Ystar / Ky
A <- matrix(c(axx, axy, ayy, ayx), byrow = T, nrow = 2, ncol= 2)
ev <- eigen(A)$values
ev[1]
A
axy
ayx
A <- matrix(c(axx, axy, ayx, ayy), byrow = T, nrow = 2, ncol= 2)
ev <- eigen(A)$values
ev[1]
ev
ev <- eigen(A)$values
ev <- eigen(A)$values
real.ev <- Re(ev)
dom.eigenvalue <- ev[Re(ev)==real.ev]
dom.eigenvalue
real.ev <- max(Re(ev))
dom.eigenvalue <- ev[Re(ev)==real.ev]
dom.eigenvalue
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig4.1.R', echo=TRUE)
fig4.1("unstable")
fig4.1("stable")
help(deSolve)
??deSolve
help(unlist)
modelpars <- list(a = 0.4, b = 0.5, c = 0.3, d = 0.3)
modelpars
unlist(modelpars)
modelpars
a
b
c
x <- unlist(modelpars)
x
x$a
a
d
list2env(modelpars)
d
c
e <- list2env(modelpars)
ls(e)
source('~/.active-rstudio-document', echo=TRUE)
list.to.parameters(modelpars)
source('~/.active-rstudio-document', echo=TRUE)
list.to.parameters(modelpars)
d
source('~/.active-rstudio-document', echo=TRUE)
list.to.parameters(modelpars)
source('~/.active-rstudio-document', echo=TRUE)
list.to.parameters(modelpars)
help(mtext)
help(eigen)
source('~/Dropbox/Desktop/Rcode/quantecol/R/lotka_volterra.R', echo=TRUE)
lotka_volterra()
source('~/Dropbox/Desktop/Rcode/quantecol/R/lotka_volterra.R', echo=TRUE)
lotka_volterra()
source('~/Dropbox/Desktop/Rcode/quantecol/R/runge.kutta.R', echo=TRUE)
lotka_volterra()
source('~/Dropbox/Desktop/Rcode/quantecol/R/lotka_volterra.R', echo=TRUE)
lotka_volterra()
lotka_volterra(1.5)
lotka_volterra(1.25)
lotka_volterra(1.1)
lotka_volterra(1.01)
library(quantecol)
lotka_volterra()
rm(list = ls())
library(quantecol)
lotka_volterra()
lotka_volterra(1.2)
