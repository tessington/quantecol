


rx=0.5
Kx=87.25
alpha=0.75
ry=0.5
Ky=87.25
beta=.75

t.perturb=20
n.years<-100



Xstart <- (Kx - alpha * Ky) / (1 - alpha * beta)
Ystart <- (Ky - beta*Kx) / (1 - alpha * beta)


# Use the Adams - Bashford method to simulate the differential equations.


run.dxtdt<-function(Xstart,
                    Ystart,
                    parslist,
                    t.perturb = 20,
                    perturb = c(1.05,1),
                    n.years = 100,
                    deltat = 0.1) {
  rm <- parslist$rm
  Km<-parslist$Km
  alpha<-parslist$alpha
  rb <- parslist$rb
  Kb <- parslist$Kb
  beta<-parslist$beta


  
  timelist <- seq(0, n.years, by = delta.t)
  n.steps<-length(timelist)

  # Functions to calculate the value of the dX/dt or dY/dt
  dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
  dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)

  # set up output matrix.
  output<-matrix(NA,nrow=n.steps,ncol=2)
  # set up matrix to hold values of dX/dt and dY/dt at time step t
  dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
  
  # initialize with starting conditions
  output[1,1:2]<-c(Xstart, Ystart)
  dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
  dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
  # use the Euler method for first time step
  output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
  output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
  
  # now use adams bashford
  for (t in 3:n.steps){
    dxdt.t.minus1 <- dXYdt.t[t-1,1]
    dydt.t.minus1 <- dXYdt.t[t-1,2]
    X.t <- output[t-1,1]
    Y.t <- output[t-1,1]
    # if this is the year of the perturbation, then adjust X and Y accordingly
    if(timelist[t] == t.perturb) {
      X.t <- X.t * perturb[1]
      Y.t <- Y.t * perturb[2]
    }
    
    dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
    dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
    Xt.plus1 <- X.t +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
    Yt.plus1 <- Y.t +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
    output[t,] <- c(Xt.plus1, Yt.plus1)
    dXYdt.t[t,] <- c(dxdt.t, dydt.t)
  }

  return(output)

}


Mstart=Mstar
Bstart=Bstar

output<-run.dxdt(Mstar,Bstar,rm, Km, alpha, rb, Kb, beta,t.perturb,mult=c(1.05,1),t.run.delta.t)

#plotfilename <- "stability_example.pdf"
#pdf(file = plotfilename, width = 5, height = 2.5)
#par(las =1,mfrow = c(1,2), mar = c(2,2,1,1))

plot((1:nrow(output))*deltat,output[,1],type="l",col="black",lwd=3,xlab="",ylab="",ylim=c(0,110),xaxs="i", axes = "F")
box()
mtext(side = 1, line = 1, text = "Time")
mtext(side = 2, line = 1, text = "State Variable", las = 0)
lines(1:nrow(output)*deltat,
      output[,2],
      type = "l",
      lwd = 3,
      col = "gray50")

alpha=1.25
beta=1.25

Km <- Mstar + Bstar*alpha
Kb <- Bstar + Mstar*beta
Mstart=Mstar
Bstart=Bstar

output<-run.dxdt(Mstar,Bstar,rm, Km, alpha, rb, Kb, beta,t.perturb,mult=c(1.05,1),t.run.delta.t)


par(las =1)
plot((1:nrow(output))*deltat,output[,1],type="l",col="black",lwd=3,xlab="",ylab="",ylim=c(0,110),xaxs="i", axes = F)
box()
mtext(side = 1, line = 1, text = "Time")
mtext(side = 2, line = 1, text = "State Variable", las = 0)

lines(1:nrow(output)*deltat,
      output[,2],
      type = "l",
      lwd = 3,
      col = "gray50")
#dev.off()
#system2("open",args = c("-a Skim.app",plotfilename))

# moviefun<-function(output){
#   thin=5
#   output<-output[seq(1,nrow(output),by=thin),1:2]
#   n.output<-nrow(output)
#   par(las=1)
#   for (i in 1:n.output) {
#   plot((1:i)*deltat*thin,output[1:i,1],type="l",col="blue",lwd=3,xlab="time",ylab="state variable",ylim=c(0,100),xaxs="i",xlim=c(0,100))
#   par(new=T)
#   plot((1:i)*deltat*thin,output[1:i,2],type="l",col="red",lwd=3,xlab="time",ylab="state variable",ylim=c(0,100),xaxs="i",xlim=c(0,100))
#   par(new=T)
#   plot((i)*deltat*thin,output[i,1],type="p",pch=21,col="blue",bg="blue",lwd=2,ylim=c(0,100),xaxs="i",xlim=c(0,100),xlab="",ylab="",axes=F)
#   par(new=T)
#   plot((i)*deltat*thin,output[i,2],type="p",pch=21,col="red",bg="red",lwd=2,ylim=c(0,100),xaxs="i",xlim=c(0,100),xlab="",ylab="",axes=F)
#   par(new=F)
# }
# }
#
#
# # function to just plot the barnacles, but show the perturbation size on the top panel
# perturb<-function(output,Mstar,perturb.scale=c(-10,10)){
#   dev.hold()
#   thin=10
#   output<-output[seq(1,nrow(output),by=thin),1:2]
#   n.output<-nrow(output)
#   par(las=1)
#   layout(c(2,1),heights=c(4,9))
#   M<-output[,1]
#   m<-M-rep(Mstar,n.output)
#   par(mai=c(1.5,1.5,0,.5))
#   for (i in 1:n.output) {
#     plot((1:i)*deltat*thin,M[1:i],type="l",col="blue",lwd=3,xlab="time",ylab="state variable",ylim=c(0,1),xaxs="i",xlim=c(0,100))
#     points((i)*deltat*thin,M[i],type="p",pch=21,col="blue",bg="blue")
#     lines(rep((i)*deltat*thin,2),c(Mstar,M[i]),lwd=2,col="red")
#     abline(h=Mstar,lty="dotted",col="blue")
#     par(mai=c(0.0,1.5,0,.5),new=F)
#     plot((1:i)*deltat*thin,m[1:i],type="l",lwd=2,xaxs="i",col="red",xlim=c(0,100),ylim=perturb.scale,xlab="",ylab="",axes=F)
#     points((i)*deltat*thin,m[i],type="p",pch=21,col="red",bg="red")
#     abline(h=0)
#     ani.pause()
#   }
# }
#
#
#
# perturb(output,Mstar,c(-75,75))
#
# moviefun(output)
# library(animation)
# saveGIF(moviefun(output),movie.name="unstable.gif")
#
# saveGIF(perturb(output,Mstar,c(-1,75)),movie.name="showunstable.gif")
#
# a=  5
# b=	2
# c=	0.3
# d=	0.3
# h=	0.05
# K=	7
#
# Nstar=d/(b*((c-d*h)))
# Pstar=1/b*(a+a*h*b*Nstar-a*Nstar/K-a*h*b*Nstar^2/K)
# run.dxdt.pp<-function(Nstart,Pstart, a, b, c, d, h, K,t.perturb,mult,t.run,delta.t) {
#   n.steps<-round(t.run/deltat,0)
#
#   dNdt<-function(N,P,a,b,c,d, h, K) a*N*(1-(N)/K)-b*N*P/(1+b*N*h)
#   dPdt<-function(N,P,a,b,c,d, h, K) c*b*N*P/(1+b*N*h)-d*P
#
#   X.vec<-matrix(NA,nrow=n.steps,ncol=2)
#
#   X.vec[1,1:2]<-c(Nstart, Pstart)
#   dXdt.save<-matrix(NA,nrow=n.steps,ncol=2)
#   dXdt.save[1,1]<- dNdt(Nstart,Pstart,a,b,c,d,h,K)
#   dXdt.save[1,2]<-dPdt(Nstart,Pstart,a,b,c,d,h,K)
#   X.vec[2,1]<-X.vec[1,1]+deltat*dNdt(Nstart,Pstart,a,b,c,d,h,K)
#   X.vec[2,2]<-X.vec[1,2]+deltat*dPdt(Nstart,Pstart,a,b,c,d,h,K)
#
#   for (t in 3:n.steps){
#     dXdt.save[t-1,]<-c(dNdt(X.vec[t-1,1],X.vec[t-1,2],a,b,c,d,h,K),dPdt(X.vec[t-1,1],X.vec[t-1,2],a,b,c,d,h,K))
#     X.vec[t,1]<-X.vec[t-1,1]+1/2*deltat*(3*dXdt.save[t-1,1]-dXdt.save[t-2,1])
#     X.vec[t,2]<-X.vec[t-1,2]+1/2*deltat*(3*dXdt.save[t-1,2]-dXdt.save[t-2,2])
#     if (t*deltat==t.perturb) X.vec[t,]<-X.vec[t,]*mult
#
#   }
#
#   return(X.vec)
#
# }
# mult=c(0.95,1)
# delta.t=0.1
# t.perturb=20
# t.run<-100
#
# output<-run.dxdt.pp(Nstar,Pstar,a,b,c,d,h,K,t.perturb,mult=c(1.05,1),t.run,delta.t)
#
# moviefun.pp<-function(output){
#   dev.hold()
#   thin=5
#   output<-output[seq(1,nrow(output),by=thin),1:2]
#   n.output<-nrow(output)
#   par(las=1)
#   for (i in 1:n.output) {
#     plot((1:i)*deltat*thin,output[1:i,1],type="l",col="blue",lwd=3,xlab="time",ylab="state variable",ylim=c(0,1),xaxs="i",xlim=c(0,100))
#     par(new=T)
#     plot((1:i)*deltat*thin,output[1:i,2],type="l",col="red",lwd=3,xlab="time",ylab="state variable",ylim=c(0,1),xaxs="i",xlim=c(0,100))
#     par(new=T)
#     plot((i)*deltat*thin,output[i,1],type="p",pch=21,col="blue",bg="blue",lwd=2,ylim=c(0,100),xaxs="i",xlim=c(0,1),xlab="",ylab="",axes=F)
#     par(new=T)
#     plot((i)*deltat*thin,output[i,2],type="p",pch=21,col="red",bg="red",lwd=2,ylim=c(0,100),xaxs="i",xlim=c(0,1),xlab="",ylab="",axes=F)
#     par(new=F)
#     ani.pause()
#   }
# }
#
# perturb(output,Nstar,c(-.3,.3))
# moviefun.pp(output)
