par(las = 1, mar = c(5, 4, 5, 1), oma = c(1,5,1,1))
layout(matrix(c(1,1,2),nrow = 1, ncol=3))
modelpars = list(r = r, K = K)
plot_cobweb(modeloutput= output, modelpars, modelname = "logistic")
par(las = 1, mar = c(5, 3, 5, 1), oma = c(1,5,1,1))
layout(matrix(c(1,1,2),nrow = 1, ncol=3))
modelpars = list(r = r, K = K)
plot_cobweb(modeloutput= output, modelpars, modelname = "logistic")
par(las = 1, mar = c(5, 5, 5, 1), oma = c(1,5,1,1))
layout(matrix(c(1,1,2),nrow = 1, ncol=3))
modelpars = list(r = r, K = K)
plot_cobweb(modeloutput= output, modelpars, modelname = "logistic")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig2.1X.R', echo=TRUE)
fig2.1X(r = 1.8)
library(quantecol)
fig2.1X(r = 1.9)
fig2.1X(r = 2.1)
fig2.1X(r = 2.7)
fig2.1X(r = 0.6)
help("fig2.1X")
library(roxygen2)
library(quantecol)
print(plot_cobweb)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
library(quantecol)
fig3.1()
F3 <- 10
F4 <- 15
F5 <- 20
S1 <- 0.2
S2 <- 0.3
S3 <- 0.4
S4 <- 0.5
# Initial Conditions
N1.start <- 20
N2.start <- 15
N3.start <- 10
N4.start <- 5
N5.start <- 1
tmax <- 50
years <- 0:tmax
n.loop <- length(years)
output <- matrix (NA, nrow = length(years), ncol = 5)
colnames(output) <- c("Age 1", "Age 2", "Age 3", "Age 4", "Age 5")
output[1,]<- c(N1.start, N2.start, N3.start, N4.start, N5.start)
####################################################################
for (i in 2:n.loop){
output[i+1,1]<- output[i, 3] * F3 + output[i, 4] * F4 + output[i,5] * F5
output[i+1,2]<- output[i,1] * S1
output[i+1,3]<- output[i,2] * S2
output[i+1,4]<- output[i,3] * S3
output[i+1,5]<- output[i,4] * S4
}
n.loop
dim(output)
i
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
fig3.1()
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
fig3.1()
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
fig3.1()
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
fig3.1()
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
fig3.1()
output <- fig3.1()
output
output$elasicity
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
output <- fig3.1()
output$elasticity
output$stable_age_eigen
A <- matrix(0, nrow = 5, ncol = 5)
A[1,3:5] <- c(F3, F4, F5)
A[2,1] <- S1
A[3,2] <- S2
A[4,3] <- S3
A[5,4] <- S4
for (i in 2:n.loop){
output[i,] <- A %*% output[i-1,]
}
# calculate population growth rate using eigenvalue
ev <- eigen(A)
eigen.vals<- ev$values
eigen.vects <- ev$vectors
lambda_eig <- Re(eigen.vals[1])
w <- Re(eigen.vects[,1])
age.distribution_eig <- w / (sum(w))
# calculate elasticitiy
evl <- eigen(t(A))
v <- Re(evl$vectors[,1])
sp <- sum(v * w)
vi.wj <- v %o% w
e <-  A  / lambda * (vi.wj / sp)
e
lambda
source('~/Dropbox/Desktop/Rcode/quantecol/R/fig3.1.R', echo=TRUE)
output <- fig3.1()
output$elasticity
library(quantecol)
help(roxygen2)
library(quantecol)
help("ode")
??ode
rx=0.5
Kx=100
alpha=0.95
ry=0.5
Ky=100
beta=.95
t.perturb=20
n.years<-100
xstar <- 51
Ystar <- 49
alpha=0.75
beta=0.75
Ky <- Mstar + Bstar*alpha
Kx <- Bstar + Mstar*beta
Ky <- Xstar + Ystar*alpha
Kx <- Ystar + Xstar*beta
Xstar <- 51
Ystar <- 49
alpha=0.75
beta=0.75
Ky <- Xstar + Ystar*alpha
Kx <- Ystar + Xstar*beta
Ky
Kx
Xstar <- 51
Ystar <- 49
alpha=0.75
beta=0.75
Ky <- Xstar + Ystar*alpha
Kx <- Ystar + Xstar*beta
Ky
Kx
delta.t <- 0.1
t.perturb = 20
peturb = c(1.05, 1)
n.years <- 100
n.steps<-round(years/deltat,0)
n.steps<-round(years/delta.t,0)
dxdt<-function(X,Y,rx,Ky,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,B,rb,Kb,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
Xstart <- Kx
Xstart <- (Kx - alpha * Ky) / (1 - alpha * beta)
Ystart <- (Ky - beta*Kx) / (1 - alpha * beta)
Xstart
Ystart
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
Xstart
Ystart
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dim(output)
years
n.steps<-round(n.years/delta.t,0)
n.steps
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
dydt<-function(X,Y,rb,Kb,beta) ry*Y*(1-(Y+beta*X)/Ky)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
# use the Euler method for first time step
output[2,1]<-output[1,1]+delta.t*dXYdt.t[1,1]
output[2,2]<-output[1,2]+delta.t*dXYdt.t[1,2]
run.dxtdt<-function(Xstart,
Ystart,
parslist,
t.perturb = 20,
perturb = c(1.05,1),
n.years = 100,
deltat = 0.1) {
rm <- parslist$rm
Km<-parslist$Km
alpha<-parslist$alpha
rb <- parslist$rb
Kb <- parslist$Kb
beta<-parslist$beta
n.steps<-round(n.years/deltat,0)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Ky,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,rb,Kb,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
X.vec[2,2]<-outputc[1,2]+deltat*dbdt(Mstart,Bstart,rb,Kb,beta)
for (t in 3:n.steps){
dXdt.save[t-1,]<-c(dmdt(X.vec[t-1,1],X.vec[t-1,2],rm,Km,alpha),dbdt(X.vec[t-1,1],X.vec[t-1,2],rb,Kb,beta))
X.vec[t,1]<-X.vec[t-1,1]+1/2*deltat*(3*dXdt.save[t-1,1]-dXdt.save[t-2,1])
X.vec[t,2]<-X.vec[t-1,2]+1/2*deltat*(3*dXdt.save[t-1,2]-dXdt.save[t-2,2])
if (t*deltat==t.perturb) X.vec[t,]<-X.vec[t,]*mult
}
return(X.vec)
}
n.steps<-round(n.years/deltat,0)
deltat <-0.1
n.steps<-round(n.years/deltat,0)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Ky,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,rb,Kb,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
X.vec[2,2]<-outputc[1,2]+deltat*dbdt(Mstart,Bstart,rb,Kb,beta)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
rx=0.5
Kx=87.25
alpha=0.75
ry=0.5
Ky=87.25
beta=.75
t.perturb=20
n.years<-100
Xstart <- (Kx - alpha * Ky) / (1 - alpha * beta)
Ystart <- (Ky - beta*Kx) / (1 - alpha * beta)
n.years = 100
deltat = 0.1
n.steps<-round(n.years/deltat,0)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
timelist <- seq(0, n.years, by = n.steps)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-1,1]
xydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- Xt +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Yt +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t,] <- c(dxdt.t, dydt.t)
}
timelist <- seq(0, n.years, by = n.steps)
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
timelist[t]
timelist
n.years
timelist <- seq(0, n.years, by = delta.t)
timellist
timelist
rx=0.5
Kx=87.25
alpha=0.75
ry=0.5
Ky=87.25
beta=.75
t.perturb=20
n.years<-100
Xstart <- (Kx - alpha * Ky) / (1 - alpha * beta)
Ystart <- (Ky - beta*Kx) / (1 - alpha * beta)
timelist <- seq(0, n.years, by = delta.t)
n.steps<-length(timelist)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-1,1]
xydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- Xt +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Yt +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t,] <- c(dxdt.t, dydt.t)
}
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-1,1]
xydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t,] <- c(dxdt.t, dydt.t)
}
dxdt.t.minus1 <- dXYdt.t[t-1,1]
xydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
cydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
dydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t,] <- c(dxdt.t, dydt.t)
timelist <- seq(0, n.years, by = delta.t)
n.steps<-length(timelist)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-1,1]
dydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t,] <- c(dxdt.t, dydt.t)
}
return(output)
}
perturb = c(1.05,1)
rm <- parslist$rm
Km<-parslist$Km
alpha<-parslist$alpha
rb <- parslist$rb
Kb <- parslist$Kb
beta<-parslist$beta
timelist <- seq(0, n.years, by = delta.t)
n.steps<-length(timelist)
# Functions to calculate the value of the dX/dt or dY/dt
dxdt<-function(X,Y,rx,Kx,alpha) rx*X*(1-(X+alpha*Y)/Kx)
dydt<-function(X,Y,ry,Ky,beta) ry*Y*(1-(Y+beta*X)/Ky)
# set up output matrix.
output<-matrix(NA,nrow=n.steps,ncol=2)
# set up matrix to hold values of dX/dt and dY/dt at time step t
dXYdt.t<-matrix(NA,nrow=n.steps,ncol=2)
# initialize with starting conditions
output[1,1:2]<-c(Xstart, Ystart)
dXYdt.t[1,1]<-dxdt(Xstart,Ystart,rx,Kx,alpha)
dXYdt.t[1,2]<-dydt(Xstart,Ystart,ry,Ky,beta)
# use the Euler method for first time step
output[2,1]<-output[1,1]+deltat*dXYdt.t[1,1]
output[2,2]<-output[1,2]+deltat*dXYdt.t[1,2]
# now use adams bashford
for (t in 3:n.steps){
dxdt.t.minus1 <- dXYdt.t[t-1,1]
dydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
# if this is the year of the perturbation, then adjust X and Y accordingly
if(timelist[t] == t.perturb) {
X.t <- X.t * perturb[1]
Y.t <- Y.t * perturb[2]
}
dxdt.t <- dxdt(X.t, Y.t, rx, Kx, alpha)
dydt.t <- dydt(X.t, Y.t, ry, Ky, alpha)
Xt.plus1 <- X.t +  delta.t /2 * (3*dxdt.t - dxdt.t.minus1[1])
Yt.plus1 <- Y.t +  delta.t /2 * (3*dydt.t - dydt.t.minus1[1])
output[t,] <- c(Xt.plus1, Yt.plus1)
dXYdt.t[t,] <- c(dxdt.t, dydt.t)
}
output
t=3
dxdt.t.minus1 <- dXYdt.t[t-1,1]
dydt.t.minus1 <- dXYdt.t[t-1,2]
X.t <- output[t-1,1]
Y.t <- output[t-1,1]
X.t
Y.t
dxdt.t.minus1
getwd()
